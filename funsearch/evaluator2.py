"""Class for evaluating programs proposed by the Sampler."""
import re
from collections.abc import Sequence
import copy
from typing import Any, Tuple, List

from funsearch import code_manipulation
from funsearch import programs_database
from funsearch import sandbox
from funsearch.code_manipulation_2 import str_to_functions, Program, header_from_str

import pathlib
import ast
import os
import textwrap

CODEBASE = ""
IMPS_PATH = pathlib.Path() / CODEBASE

MAP = {} # maps func name -> {'file_path': , 'function_name':  , 'line_no': , 'class': , 'header': }

def get_relative_path(absolute_path: pathlib.Path, project_root: str) -> pathlib.Path:
    """Get the file path of the provided function relative to the project root."""
    relative_path = absolute_path.relative_to(project_root)
    return relative_path

def _save_sample(
    sample: str,
    curr_id: str,
) -> Program:
  """Given sampler code, saves it in the implementation dir by current ID. Save in form accessible to decorator"""
  sample = sample.strip() 
  functions = str_to_functions(sample)
  func_names = [f.name for f in functions]
  func_headers = [str(f.header) for f in functions]
  func_headers 
  expected_names = list(MAP.keys())
  expected_headers = [str(header_from_str(MAP[name]['header'])) for name in expected_names]
  
  # check if names are exactly same
  if set(func_names) != set(expected_names):
    raise ValueError(f"Function names do not match. Expected: {expected_names}, got: {func_names}")
  
  # check if headers are same
  if set(func_headers) != set(expected_headers):
    raise ValueError(f"Function headers do not match. Expected: {expected_headers}, got: {func_headers}")

  for function in functions:
    function_name = function.name
    function_body = textwrap.dedent(function.body).strip() + '\n'
    function.path = MAP[function_name]['file_path']
    function.class_name = MAP[function_name]['class']
    func_file_path = pathlib.Path(MAP[function_name]['file_path'])
    func_file_path = get_relative_path(func_file_path, CODEBASE)
    func_file_path = IMPS_PATH / func_file_path 
    os.makedirs(func_file_path, exist_ok=True)
    func_file_path = func_file_path / f"{function_name} {curr_id}"
    with open(func_file_path, "w") as f:
      f.write(function_body)

  return Program(functions=functions)

class Evaluator:
  """Class that analyses functions generated by LLMs."""

  def __init__(
      self,
      database: programs_database.ProgramsDatabase,
      sbox: sandbox.DummySandbox,
      template: code_manipulation.Program,
      function_to_evolve: str,
      function_to_run: str,
      inputs: Sequence[Any],
      timeout_seconds: int = 30,
  ):
    self._database = database
    self._template = template
    self._function_to_evolve = function_to_evolve
    self._function_to_run = function_to_run
    self._inputs = inputs
    self._timeout_seconds = timeout_seconds
    self._sandbox = sbox

  def analyse(
      self,
      sample: str,
      island_id: int | None,
      curr_id: str
  ) -> None:
    """Compiles the sample into a program and executes it on test inputs."""
    
    program = _save_sample(sample, curr_id)

    scores_per_test = {}
    for current_input in self._inputs:
      test_output, runs_ok = self._sandbox.run(
          program, self._function_to_run, current_input, self._timeout_seconds, curr_id)
      if (runs_ok and test_output is not None):
        if not isinstance(test_output, (int, float)):
          raise ValueError('@function.run did not return an int/float score.')
        scores_per_test[current_input] = test_output
    if scores_per_test:
      self._database.register_program(program, island_id, scores_per_test)
