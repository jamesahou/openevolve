"""Class for evaluating programs proposed by the Sampler."""
import re
from collections.abc import Sequence
import copy
from typing import Any, Tuple, List, Dict

from funsearch import code_manipulation
from funsearch import programs_database_2
from funsearch import sandbox
from funsearch.code_manipulation_2 import Program, header_from_str, structured_output_to_functions

import pathlib
import ast
import os
import textwrap

CODEBASE = ""
IMPS_PATH = pathlib.Path() / CODEBASE

MAP = {} # maps rel func name -> {'file_path': , 'function_name':  , 'line_no': , 'class': , 'header': }

def get_relative_path(absolute_path: pathlib.Path, project_root: str) -> pathlib.Path:
    """Get the file path of the provided function relative to the project root."""
    relative_path = absolute_path.relative_to(project_root)
    return relative_path

def _save_sample(
    sample: Dict[str, str],
    curr_id: str,
) -> Program:
  """Given sampler code in structured format, saves it in the implementation dir by current ID. Save in form accessible to decorator"""
  
  # Check if the sample contains all the expected keys
  expected_names = set(MAP.keys())
  if not set(sample.keys()) == expected_names:
    raise ValueError(f"Sample keys do not match expected function names. Expected: {expected_names}, got: {sample.keys()}")

  functions = structured_output_to_functions(sample)
  func_headers = [str(f.header) for f in functions.values()]
  expected_headers = [str(header_from_str(MAP[name]['header'])) for name in expected_names]

  # check if headers are same
  if set(func_headers) != set(expected_headers):
    raise ValueError(f"Function headers do not match expected headers. Expected: {expected_headers}, got: {func_headers}")

  for function_name, function in functions.items():
    function_body = textwrap.dedent(function.body).strip() + '\n'

    func_abs_path = pathlib.Path(MAP[function_name]['file_path'])
    func_rel_path = get_relative_path(func_abs_path, CODEBASE)
    func_file_path = IMPS_PATH / func_rel_path 
    os.makedirs(func_file_path, exist_ok=True)

    function.relative_path = str(func_rel_path)
    function.class_name = MAP[function_name]['class']
    function.line_no = MAP[function_name]['line_no']
    function.qual_name = function_name

    func_file_path = func_file_path / f"{function_name} {curr_id}"
    with open(func_file_path, "w") as f:
      f.write(function_body)

  return Program(functions=functions.values())

class Evaluator:
  """Class that analyses functions generated by LLMs."""

  def __init__(
      self,
      database: programs_database_2.ProgramsDatabase,
      sbox: sandbox.DummySandbox,
      template: code_manipulation.Program,
      eval_file: pathlib.Path,
      inputs: Sequence[Any],
      timeout_seconds: int = 30,
  ):
    self._database = database
    self._template = template
    self._inputs = inputs
    self._timeout_seconds = timeout_seconds
    self._sandbox = sbox
    self._eval_file = eval_file

  def analyse(
      self,
      sample: Dict[str, str],
      island_id: int | None,
      curr_id: str
  ) -> None:
    """Compiles the sample into a program and executes it on test inputs."""
    
    program = _save_sample(sample, curr_id)

    scores_per_test = {}
    for current_input in self._inputs:
      test_output, runs_ok = self._sandbox.run(
          program, self._eval_file, current_input, self._timeout_seconds, curr_id)
      if (runs_ok and test_output is not None):
        if not isinstance(test_output, (int, float)):
          raise ValueError('@function.run did not return an int/float score.')
        scores_per_test[current_input] = test_output
    if scores_per_test:
      self._database.register_program(program, island_id, scores_per_test)
