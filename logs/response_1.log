functions=[FunctionImplementation(filepath='astropy/coordinates/funcs.py', qualname='concatenate_v0', code='from astropy.coordinates import SkyCoord\nfrom astropy.coordinates.representation import concatenate_representations\nfrom astropy.utils.misc import isiterable\n\ndef concatenate_v0(coords):\n    """\n    Combine multiple coordinate objects into a single\n    `~astropy.coordinates.SkyCoord`.\n\n    "Coordinate objects" here mean frame objects with data,\n    `~astropy.coordinates.SkyCoord`, or representation objects.  Currently,\n    they must all be in the same frame, but in a future version this may be\n    relaxed to allow inhomogeneous sequences of objects.\n\n    Parameters\n    ----------\n    coords : sequence of coordinate-like\n        The objects to concatenate\n\n    Returns\n    -------\n    cskycoord : SkyCoord\n        A single sky coordinate with its data set to the concatenation of all\n        the elements in ``coords``\n    """\n    if getattr(coords, \'isscalar\', False) or not isiterable(coords):\n        raise TypeError(\'The argument to concatenate must be iterable\')\n\n    scs = [SkyCoord(coord, copy=False) for coord in coords]\n    if not scs:\n        return SkyCoord()\n    for sc in scs[1:]:\n        if not sc.is_equivalent_frame(scs[0]):\n            raise ValueError(f\'All inputs must have equivalent frames: {sc} != {scs[0]}\')\n    return SkyCoord(concatenate_representations([c.data for c in scs]), frame=scs[0].frame)'), FunctionImplementation(filepath='astropy/coordinates/sky_coordinate.py', qualname='__init___v0', code="from astropy.coordinates.baseframe import BaseCoordinateFrame\nfrom astropy.coordinates.sky_coordinate import SkyCoord\n\ndef __init___v0(self, *args, copy=True, **kwargs):\n    self._extra_frameattr_names = set()\n    if len(args) == 1 and not kwargs and isinstance(args[0], (BaseCoordinateFrame, SkyCoord)):\n        coords = args[0]\n        if isinstance(coords, SkyCoord):\n            self._extra_frameattr_names = coords._extra_frameattr_names\n            self.info = coords.info\n            for attr_name in self._extra_frameattr_names:\n                setattr(self, attr_name, getattr(coords, attr_name))\n            coords = coords.frame\n        if not coords.has_data:\n            raise ValueError('Cannot initialize from a coordinate frame instance without coordinate data')\n        if copy:\n            self._sky_coord_frame = coords.copy()\n        else:\n            self._sky_coord_frame = coords\n    else:\n        frame_cls, frame_kwargs = _get_frame_without_data(args, kwargs)\n        args = list(args)\n        skycoord_kwargs, components, info = _parse_coordinate_data(frame_cls(**frame_kwargs), args, kwargs)\n        for attr in skycoord_kwargs:\n            setattr(self, attr, skycoord_kwargs[attr])\n        if info is not None:\n            self.info = info\n        frame_kwargs.update(components)\n        self._sky_coord_frame = frame_cls(copy=copy, **frame_kwargs)\n        if not self._sky_coord_frame.has_data:\n            raise ValueError('Cannot create a SkyCoord without data')"), FunctionImplementation(filepath='astropy/coordinates/sky_coordinate_parsers.py', qualname='_parse_coordinate_data_v0', code='from astropy.coordinates.representation import SphericalRepresentation, UnitSphericalRepresentation\nfrom astropy.coordinates.frame_transform_graph import frame_transform_graph\nimport numpy as np\nfrom astropy.coordinates.angles import Longitude, Latitude\nfrom astropy import units as u\nfrom astropy.coordinates.base_representation import BaseRepresentation\nfrom typing import Sequence\nfrom astropy.utils import isiterable\nfrom astropy.coordinates.sky_coordinate import SkyCoord\n\n_conflict_err_msg = \'Multiple values for coordinate attribute {0} provided; got {1}, overriding with {2} in {3}\'\nCOPY_IF_NEEDED = True\n\ndef _parse_coordinate_data_v0(args, frame, kwargs):\n    """\n    Extract coordinate data from the args and kwargs passed to SkyCoord.\n\n    By this point, we assume that all of the frame attributes have been\n    extracted from kwargs (see _get_frame_without_data()), so all that are left\n    are (1) extra SkyCoord attributes, and (2) the coordinate data, specified in\n    any of the valid ways.\n    """\n    valid_skycoord_kwargs = {}\n    valid_components = {}\n    info = None\n\n    # First, get any SkyCoord attributes from the kwargs\n    attr_names = list(kwargs.keys())\n    for attr in attr_names:\n        if attr in frame_transform_graph.frame_attributes:\n            valid_skycoord_kwargs[attr] = kwargs.pop(attr)\n\n    # Get the units for the representation components\n    units = _get_representation_component_units(args, kwargs)\n\n    # Get any representation component attributes from the kwargs\n    valid_components.update(_get_representation_attrs(frame, units, kwargs))\n\n    if kwargs:\n        pm_message = \'\'\n        if frame.representation_type == SphericalRepresentation:\n            frame_names = list(frame.get_representation_component_names().keys())\n            lon_name = frame_names[0]\n            lat_name = frame_names[1]\n            if f\'pm_{lon_name}\' in list(kwargs.keys()):\n                pm_message = f\'\\n\\n By default, most frame classes expect the longitudinal proper motion to include the cos(latitude) term, named `pm_{lon_name}_cos{lat_name}`. Did you mean to pass in this component?\'\n        raise ValueError(\'Unrecognized keyword argument(s) {}{}\'.format(\', \'.join((f"\'{key}\'" for key in kwargs)), pm_message))\n\n    # Parse the coordinate data from the args\n    if args:\n        if len(args) == 1:\n            _skycoord_kwargs, _components = _parse_coordinate_arg(args[0], frame, units, kwargs)\n            if hasattr(args[0], \'info\'):\n                info = args[0].info\n        elif len(args) <= 3:\n            _skycoord_kwargs = {}\n            _components = {}\n            frame_attr_names = list(frame.representation_component_names.keys())\n            repr_attr_names = list(frame.representation_component_names.values())\n            for arg, frame_attr_name, repr_attr_name, unit in zip(args, frame_attr_names, repr_attr_names, units):\n                attr_class = frame.representation_type.attr_classes[repr_attr_name]\n                _components[frame_attr_name] = attr_class(arg, unit=unit)\n        else:\n            raise ValueError(f\'Must supply no more than three positional arguments, got {len(args)}\')\n\n        # Check for conflicts between positional and keyword arguments\n        for attr, coord_value in _components.items():\n            if attr in valid_components:\n                raise ValueError(_conflict_err_msg.format(attr, coord_value, valid_components[attr], \'SkyCoord\'))\n            valid_components[attr] = coord_value\n        for attr, value in _skycoord_kwargs.items():\n            if attr in valid_skycoord_kwargs and np.any(valid_skycoord_kwargs[attr] != value):\n                raise ValueError(_conflict_err_msg.format(attr, value, valid_skycoord_kwargs[attr], \'SkyCoord\'))\n            valid_skycoord_kwargs[attr] = value\n\n    return (valid_skycoord_kwargs, valid_components, info)\n\n\ndef _parse_coordinate_arg_v0(coords, frame, init_kwargs, units):\n    """\n    Single unnamed arg supplied.  This must be:\n    - Coordinate frame with data\n    - Representation\n    - SkyCoord\n    - List or tuple of:\n      - String which splits into two values\n      - Iterable with two values\n      - SkyCoord, frame, or representation objects.\n\n    Returns a dict mapping coordinate attribute names to values (or lists of\n    values)\n    """\n    is_scalar = False\n    components = {}\n    skycoord_kwargs = {}\n    frame_attr_names = list(frame.representation_component_names.keys())\n    repr_attr_names = list(frame.representation_component_names.values())\n    repr_attr_classes = list(frame.representation_type.attr_classes.values())\n    n_attr_names = len(repr_attr_names)\n\n    if isinstance(coords, str):\n        is_scalar = True\n        coords = [coords]\n\n    if isinstance(coords, (SkyCoord, BaseCoordinateFrame)):\n        if not coords.has_data:\n            raise ValueError(\'Cannot initialize from a frame without coordinate data\')\n        data = coords.data.represent_as(frame.representation_type)\n\n        if isinstance(coords.data, UnitSphericalRepresentation):\n            try:\n                index = repr_attr_names.index(\'distance\')\n            except ValueError:\n                pass\n            else:\n                del repr_attr_names[index]\n                del units[index]\n                del frame_attr_names[index]\n                del repr_attr_classes[index]\n\n        values = [getattr(data, name) for name in repr_attr_names]\n\n        if coords.data.differentials and \'s\' in coords.data.differentials:\n            orig_vel = coords.data.differentials[\'s\']\n            vel = coords.data.represent_as(frame.representation_type, frame.get_representation_cls(\'s\')).differentials[\'s\']\n            for frname, reprname in frame.get_representation_component_names(\'s\').items():\n                if reprname == \'d_distance\' and (not hasattr(orig_vel, reprname)) and (\'unit\' in orig_vel.get_name()):\n                    continue\n                values.append(getattr(vel, reprname))\n                units.append(None)\n                frame_attr_names.append(frname)\n                repr_attr_names.append(reprname)\n                repr_attr_classes.append(vel.attr_classes[reprname])\n\n        is_skycoord = isinstance(coords, SkyCoord)\n        for attr in frame_transform_graph.frame_attributes:\n            if (value := getattr(coords, attr, None)) is not None and (is_skycoord or attr not in coords.frame_attributes):\n                skycoord_kwargs[attr] = value\n\n    elif isinstance(coords, BaseRepresentation):\n        if coords.differentials and \'s\' in coords.differentials:\n            diffs = frame.get_representation_cls(\'s\')\n            data = coords.represent_as(frame.representation_type, diffs)\n            values = [getattr(data, name) for name in repr_attr_names]\n            for frname, reprname in frame.get_representation_component_names(\'s\').items():\n                values.append(getattr(data.differentials[\'s\'], reprname))\n                units.append(None)\n                frame_attr_names.append(frname)\n                repr_attr_names.append(reprname)\n                repr_attr_classes.append(data.differentials[\'s\'].attr_classes[reprname])\n        else:\n            data = coords.represent_as(frame.representation_type)\n            values = [getattr(data, name) for name in repr_attr_names]\n\n    elif isinstance(coords, np.ndarray) and coords.dtype.kind in \'if\' and (coords.ndim == 2) and (coords.shape[1] <= 3):\n        values = coords.transpose()\n\n    elif isinstance(coords, (Sequence, np.ndarray)):\n        coord_types = (SkyCoord, BaseCoordinateFrame, BaseRepresentation)\n        if any((isinstance(coord, coord_types) for coord in coords)):\n            scs = [SkyCoord(coord, **init_kwargs) for coord in coords]\n            for sc in scs[1:]:\n                if not sc.is_equivalent_frame(scs[0]):\n                    raise ValueError(f"List of inputs don\'t have equivalent frames: {sc} != {scs[0]}")\n\n            not_unit_sphere = not isinstance(scs[0].data, UnitSphericalRepresentation)\n            for fattrnm in scs[0].frame.frame_attributes:\n                skycoord_kwargs[fattrnm] = getattr(scs[0].frame, fattrnm)\n            for fattrnm in scs[0]._extra_frameattr_names:\n                skycoord_kwargs[fattrnm] = getattr(scs[0], fattrnm)\n            values = [np.concatenate([np.atleast_1d(getattr(sc, data_attr)) for sc in scs]) for data_attr, repr_attr in zip(frame_attr_names, repr_attr_names) if not_unit_sphere or repr_attr != \'distance\']\n\n        else:\n            is_radec = \'ra\' in frame.representation_component_names and \'dec\' in frame.representation_component_names\n            vals = [_parse_one_coord_str(c, is_radec=is_radec) if isinstance(c, str) else c for c in coords]\n            try:\n                n_coords = {len(x) for x in vals}\n            except Exception as err:\n                raise ValueError(\'One or more elements of input sequence does not have a length.\') from err\n\n            if len(n_coords) > 1:\n                raise ValueError(f\'Input coordinate values must have same number of elements, found {sorted(n_coords)}\')\n            n_coords = n_coords.pop()\n            if n_coords > n_attr_names:\n                raise ValueError(f\'Input coordinates have {n_coords} values but representation {frame.representation_type.get_name()} only accepts {n_attr_names}\')\n\n            values = [list(x) for x in zip(*vals)]\n            if is_scalar:\n                values = [x[0] for x in values]\n\n    else:\n        raise ValueError(\'Cannot parse coordinates from first argument\')\n\n    try:\n        for frame_attr_name, repr_attr_class, value, unit in zip(frame_attr_names, repr_attr_classes, values, units):\n            components[frame_attr_name] = repr_attr_class(value, unit=unit, copy=COPY_IF_NEEDED)\n    except Exception as err:\n        raise ValueError(f\'Cannot parse first argument data "{value}" for attribute {frame_attr_name}\') from err\n\n    return (skycoord_kwargs, components)\n\n\n\n\ndef _parse_one_coord_str(s, is_radec=False):\n    if \',\' in s:\n        spl = s.split(\',\')\n    elif \' \' in s:\n        spl = s.split()\n    else:\n        return s\n\n    if len(spl) == 2:\n        return [x.strip() for x in spl]\n\n    raise ValueError(f\'Could not parse coordinate string: "{s}"\')\n\n\ndef _get_representation_component_units(args, kwargs):\n    units = []\n    for arg in args:\n        if isinstance(arg, (Longitude, Latitude)):\n            units.append(arg.unit)\n        elif isinstance(arg, (np.ndarray, u.Quantity)):\n            try:\n                units.append(arg.unit)\n            except AttributeError:\n                units.append(None)\n        else:\n            units.append(None)\n    return units\n\n\n\ndef _get_representation_attrs(frame, units, kwargs):\n    components = {}\n    repr_attr_names = frame.representation_component_names.values()\n    repr_attr_classes = frame.representation_type.attr_classes\n    for repr_attr_name, attr_class in repr_attr_classes.items():\n        if repr_attr_name in kwargs:\n            val = kwargs.pop(repr_attr_name)\n            unit = None\n            if attr_class is Longitude:\n                unit = units[0] if units else None\n            elif attr_class is Latitude:\n                unit = units[1] if len(units) > 1 else (units[0] if units else None)\n            components[repr_attr_name] = attr_class(val, unit=unit)\n    return components'), FunctionImplementation(filepath='astropy/coordinates/sky_coordinate_parsers.py', qualname='_parse_coordinate_arg_v0', code='from astropy.coordinates.representation import SphericalRepresentation, UnitSphericalRepresentation\nfrom astropy.coordinates.frame_transform_graph import frame_transform_graph\nimport numpy as np\nfrom astropy.coordinates.angles import Longitude, Latitude\nfrom astropy import units as u\nfrom astropy.coordinates.base_representation import BaseRepresentation\nfrom typing import Sequence\nfrom astropy.utils import isiterable\nfrom astropy.coordinates.sky_coordinate import SkyCoord\n\n_conflict_err_msg = \'Multiple values for coordinate attribute {0} provided; got {1}, overriding with {2} in {3}\'\nCOPY_IF_NEEDED = True\n\ndef _parse_coordinate_data_v0(args, frame, kwargs):\n    """\n    Extract coordinate data from the args and kwargs passed to SkyCoord.\n\n    By this point, we assume that all of the frame attributes have been\n    extracted from kwargs (see _get_frame_without_data()), so all that are left\n    are (1) extra SkyCoord attributes, and (2) the coordinate data, specified in\n    any of the valid ways.\n    """\n    valid_skycoord_kwargs = {}\n    valid_components = {}\n    info = None\n\n    # First, get any SkyCoord attributes from the kwargs\n    attr_names = list(kwargs.keys())\n    for attr in attr_names:\n        if attr in frame_transform_graph.frame_attributes:\n            valid_skycoord_kwargs[attr] = kwargs.pop(attr)\n\n    # Get the units for the representation components\n    units = _get_representation_component_units(args, kwargs)\n\n    # Get any representation component attributes from the kwargs\n    valid_components.update(_get_representation_attrs(frame, units, kwargs))\n\n    if kwargs:\n        pm_message = \'\'\n        if frame.representation_type == SphericalRepresentation:\n            frame_names = list(frame.get_representation_component_names().keys())\n            lon_name = frame_names[0]\n            lat_name = frame_names[1]\n            if f\'pm_{lon_name}\' in list(kwargs.keys()):\n                pm_message = f\'\\n\\n By default, most frame classes expect the longitudinal proper motion to include the cos(latitude) term, named `pm_{lon_name}_cos{lat_name}`. Did you mean to pass in this component?\'\n        raise ValueError(\'Unrecognized keyword argument(s) {}{}\'.format(\', \'.join((f"\'{key}\'" for key in kwargs)), pm_message))\n\n    # Parse the coordinate data from the args\n    if args:\n        if len(args) == 1:\n            _skycoord_kwargs, _components = _parse_coordinate_arg(args[0], frame, units, kwargs)\n            if hasattr(args[0], \'info\'):\n                info = args[0].info\n        elif len(args) <= 3:\n            _skycoord_kwargs = {}\n            _components = {}\n            frame_attr_names = list(frame.representation_component_names.keys())\n            repr_attr_names = list(frame.representation_component_names.values())\n            for arg, frame_attr_name, repr_attr_name, unit in zip(args, frame_attr_names, repr_attr_names, units):\n                attr_class = frame.representation_type.attr_classes[repr_attr_name]\n                _components[frame_attr_name] = attr_class(arg, unit=unit)\n        else:\n            raise ValueError(f\'Must supply no more than three positional arguments, got {len(args)}\')\n\n        # Check for conflicts between positional and keyword arguments\n        for attr, coord_value in _components.items():\n            if attr in valid_components:\n                raise ValueError(_conflict_err_msg.format(attr, coord_value, valid_components[attr], \'SkyCoord\'))\n            valid_components[attr] = coord_value\n        for attr, value in _skycoord_kwargs.items():\n            if attr in valid_skycoord_kwargs and np.any(valid_skycoord_kwargs[attr] != value):\n                raise ValueError(_conflict_err_msg.format(attr, value, valid_skycoord_kwargs[attr], \'SkyCoord\'))\n            valid_skycoord_kwargs[attr] = value\n\n    return (valid_skycoord_kwargs, valid_components, info)\n\n\ndef _parse_coordinate_arg_v0(coords, frame, init_kwargs, units):\n    """\n    Single unnamed arg supplied.  This must be:\n    - Coordinate frame with data\n    - Representation\n    - SkyCoord\n    - List or tuple of:\n      - String which splits into two values\n      - Iterable with two values\n      - SkyCoord, frame, or representation objects.\n\n    Returns a dict mapping coordinate attribute names to values (or lists of\n    values)\n    """\n    is_scalar = False\n    components = {}\n    skycoord_kwargs = {}\n    frame_attr_names = list(frame.representation_component_names.keys())\n    repr_attr_names = list(frame.representation_component_names.values())\n    repr_attr_classes = list(frame.representation_type.attr_classes.values())\n    n_attr_names = len(repr_attr_names)\n\n    if isinstance(coords, str):\n        is_scalar = True\n        coords = [coords]\n\n    if isinstance(coords, (SkyCoord, BaseCoordinateFrame)):\n        if not coords.has_data:\n            raise ValueError(\'Cannot initialize from a frame without coordinate data\')\n        data = coords.data.represent_as(frame.representation_type)\n\n        if isinstance(coords.data, UnitSphericalRepresentation):\n            try:\n                index = repr_attr_names.index(\'distance\')\n            except ValueError:\n                pass\n            else:\n                del repr_attr_names[index]\n                del units[index]\n                del frame_attr_names[index]\n                del repr_attr_classes[index]\n\n        values = [getattr(data, name) for name in repr_attr_names]\n\n        if coords.data.differentials and \'s\' in coords.data.differentials:\n            orig_vel = coords.data.differentials[\'s\']\n            vel = coords.data.represent_as(frame.representation_type, frame.get_representation_cls(\'s\')).differentials[\'s\']\n            for frname, reprname in frame.get_representation_component_names(\'s\').items():\n                if reprname == \'d_distance\' and (not hasattr(orig_vel, reprname)) and (\'unit\' in orig_vel.get_name()):\n                    continue\n                values.append(getattr(vel, reprname))\n                units.append(None)\n                frame_attr_names.append(frname)\n                repr_attr_names.append(reprname)\n                repr_attr_classes.append(vel.attr_classes[reprname])\n\n        is_skycoord = isinstance(coords, SkyCoord)\n        for attr in frame_transform_graph.frame_attributes:\n            if (value := getattr(coords, attr, None)) is not None and (is_skycoord or attr not in coords.frame_attributes):\n                skycoord_kwargs[attr] = value\n\n    elif isinstance(coords, BaseRepresentation):\n        if coords.differentials and \'s\' in coords.differentials:\n            diffs = frame.get_representation_cls(\'s\')\n            data = coords.represent_as(frame.representation_type, diffs)\n            values = [getattr(data, name) for name in repr_attr_names]\n            for frname, reprname in frame.get_representation_component_names(\'s\').items():\n                values.append(getattr(data.differentials[\'s\'], reprname))\n                units.append(None)\n                frame_attr_names.append(frname)\n                repr_attr_names.append(reprname)\n                repr_attr_classes.append(data.differentials[\'s\'].attr_classes[reprname])\n        else:\n            data = coords.represent_as(frame.representation_type)\n            values = [getattr(data, name) for name in repr_attr_names]\n\n    elif isinstance(coords, np.ndarray) and coords.dtype.kind in \'if\' and (coords.ndim == 2) and (coords.shape[1] <= 3):\n        values = coords.transpose()\n\n    elif isinstance(coords, (Sequence, np.ndarray)):\n        coord_types = (SkyCoord, BaseCoordinateFrame, BaseRepresentation)\n        if any((isinstance(coord, coord_types) for coord in coords)):\n            scs = [SkyCoord(coord, **init_kwargs) for coord in coords]\n            for sc in scs[1:]:\n                if not sc.is_equivalent_frame(scs[0]):\n                    raise ValueError(f"List of inputs don\'t have equivalent frames: {sc} != {scs[0]}")\n\n            not_unit_sphere = not isinstance(scs[0].data, UnitSphericalRepresentation)\n            for fattrnm in scs[0].frame.frame_attributes:\n                skycoord_kwargs[fattrnm] = getattr(scs[0].frame, fattrnm)\n            for fattrnm in scs[0]._extra_frameattr_names:\n                skycoord_kwargs[fattrnm] = getattr(scs[0], fattrnm)\n            values = [np.concatenate([np.atleast_1d(getattr(sc, data_attr)) for sc in scs]) for data_attr, repr_attr in zip(frame_attr_names, repr_attr_names) if not_unit_sphere or repr_attr != \'distance\']\n\n        else:\n            is_radec = \'ra\' in frame.representation_component_names and \'dec\' in frame.representation_component_names\n            vals = [_parse_one_coord_str(c, is_radec=is_radec) if isinstance(c, str) else c for c in coords]\n            try:\n                n_coords = {len(x) for x in vals}\n            except Exception as err:\n                raise ValueError(\'One or more elements of input sequence does not have a length.\') from err\n\n            if len(n_coords) > 1:\n                raise ValueError(f\'Input coordinate values must have same number of elements, found {sorted(n_coords)}\')\n            n_coords = n_coords.pop()\n            if n_coords > n_attr_names:\n                raise ValueError(f\'Input coordinates have {n_coords} values but representation {frame.representation_type.get_name()} only accepts {n_attr_names}\')\n\n            values = [list(x) for x in zip(*vals)]\n            if is_scalar:\n                values = [x[0] for x in values]\n\n    else:\n        raise ValueError(\'Cannot parse coordinates from first argument\')\n\n    try:\n        for frame_attr_name, repr_attr_class, value, unit in zip(frame_attr_names, repr_attr_classes, values, units):\n            components[frame_attr_name] = repr_attr_class(value, unit=unit, copy=COPY_IF_NEEDED)\n    except Exception as err:\n        raise ValueError(f\'Cannot parse first argument data "{value}" for attribute {frame_attr_name}\') from err\n\n    return (skycoord_kwargs, components)\n'), FunctionImplementation(filepath='astropy/coordinates/angles/core.py', qualname='Longitude.__new___v0', code="from astropy.coordinates.angles.core import Latitude\n\ndef __new___v0(cls, angle, unit=None, wrap_angle=None, **kwargs):\n    if isinstance(angle, Latitude):\n        raise TypeError('A Longitude angle cannot be created from a Latitude angle.')\n\n    self = super().__new__(cls, angle, unit=unit, **kwargs)\n\n    if wrap_angle is None:\n        wrap_angle = getattr(angle, 'wrap_angle', self._default_wrap_angle)\n\n    self.wrap_angle = wrap_angle\n    return self"), FunctionImplementation(filepath='astropy/coordinates/angles/core.py', qualname='wrap_angle_v0', code='def wrap_angle_v0(self):\n    return self._wrap_angle'), FunctionImplementation(filepath='astropy/coordinates/angles/core.py', qualname='_wrap_at_v0', code='from astropy import units as u\nimport numpy as np\nfrom astropy.utils.compat import NUMPY_LT_2_0\n\ndef _wrap_at_v0(self, wrap_angle):\n    """\n    Implementation that assumes ``angle`` is already validated\n    and that wrapping is inplace.\n    """\n    a360 = u.degree.to(self.unit, 360.0)\n    wrap_angle = wrap_angle.to_value(self.unit)\n    self_angle = self.view(np.ndarray)\n    if NUMPY_LT_2_0:\n        self_angle = self_angle[np.newaxis]\n    else:\n        wrap_angle = float(wrap_angle)\n    wrap_angle_floor = wrap_angle - a360\n    with np.errstate(invalid=\'ignore\'):\n        wraps = (self_angle - wrap_angle_floor) // a360\n    valid = np.isfinite(wraps) & (wraps != 0)\n    if np.any(valid):\n        self_angle -= wraps * a360\n        self_angle[self_angle >= wrap_angle] -= a360\n        self_angle[self_angle < wrap_angle_floor] += a360')]