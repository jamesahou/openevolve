functions=[FunctionImplementation(filepath='astropy/coordinates/funcs.py', qualname='concatenate', code='from astropy.coordinates.sky_coordinate import SkyCoord\nfrom astropy.coordinates.representation import concatenate_representations\nfrom astropy.utils.misc import isiterable\nfrom astropy import units as u\nimport numpy as np\n\ndef concatenate(coords):\n    """\n    Combine multiple coordinate objects into a single\n    `~astropy.coordinates.SkyCoord`.\n\n    '), FunctionImplementation(filepath='astropy/coordinates/sky_coordinate.py', qualname='SkyCoord.__init__', code="from astropy.coordinates.baseframe import BaseCoordinateFrame\nfrom astropy.coordinates.sky_coordinate import SkyCoord\nfrom astropy.coordinates.representation import BaseRepresentation\nfrom astropy.utils.exceptions import AstropyUserWarning\nfrom astropy import units as u\n\n\ndef __init__(self, *args, copy=True, **kwargs):\n    self._extra_frameattr_names = set()\n    if len(args) == 1 and not kwargs and isinstance(args[0], (BaseCoordinateFrame, SkyCoord)):\n        coords = args[0]\n        if isinstance(coords, SkyCoord):\n            self._extra_frameattr_names = coords._extra_frameattr_names\n            self.info = coords.info\n            for attr_name in self._extra_frameattr_names:\n                setattr(self, attr_name, getattr(coords, attr_name))\n            coords = coords.frame\n        if not coords.has_data:\n            raise ValueError('Cannot initialize from a coordinate frame instance without coordinate data')\n        if copy:\n            self._sky_coord_frame = coords.copy()\n        else:\n            self._sky_coord_frame = coords\n    else:\n        frame_cls, frame_kwargs = _get_frame_without_data(args, kwargs)\n        args = list(args)\n        skycoord_kwargs, components, info = _parse_coordinate_data(frame_cls(**frame_kwargs), args, kwargs)\n        for attr in skycoord_kwargs:\n            setattr(self, attr, skycoord_kwargs[attr])\n        if info is not None:\n            self.info = info\n        frame_kwargs.update(components)\n        self._sky_coord_frame = frame_cls(copy=copy, **frame_kwargs)\n        if not self._sky_coord_frame.has_data:\n            raise ValueError('Cannot create a SkyCoord without data')\n"), FunctionImplementation(filepath='astropy/coordinates/sky_coordinate_parsers.py', qualname='_parse_coordinate_data', code='from astropy.coordinates.angles import Angle\nfrom astropy.coordinates.representation import (SphericalRepresentation, UnitSphericalRepresentation, \n                                                BaseRepresentation, ) \nfrom astropy.coordinates.baseframe import frame_transform_graph\nimport numpy as np\nfrom astropy.utils.misc import isiterable\nfrom astropy.coordinates.sky_coordinate import SkyCoord\nfrom astropy.coordinates.baseframe import BaseCoordinateFrame\nfrom astropy.coordinates.angles import Longitude, Latitude\nfrom astropy import units as u\nfrom copy import copy as COPY_IF_NEEDED\nfrom collections.abc import Sequence\n\n\n_conflict_err_msg = (\n    "Cannot set coordinate attribute \'{0}\' to {1} because it already has a value of {2} "\n    "from {3}"\n)\n\ndef _parse_coordinate_data(frame, args, kwargs):\n    """\n    Extract coordinate data from the args and kwargs passed to SkyCoord.\n\n    By this point, we assume that all of the frame attributes have been\n    extracted from kwargs (see _get_frame_without_data()), so all that are left\n    are (1) extra SkyCoord attributes, and (2) the coordinate data, specified in\n    any of the valid ways.\n    """\n    valid_skycoord_kwargs = {}\n    valid_components = {}\n    info = None\n\n    # Extract SkyCoord attributes from kwargs.\n    for attr, value in list(kwargs.items()):  # Iterate over a copy of keys to allow popping.\n        if attr in frame_transform_graph.frame_attributes:\n            valid_skycoord_kwargs[attr] = kwargs.pop(attr)\n\n    # Get units for representation components.\n    units = _get_representation_component_units(args, kwargs)\n\n    # Get representation attributes from kwargs.\n    valid_components.update(_get_representation_attrs(frame, units, kwargs))\n\n    # Error if there are any unrecognized kwargs.\n    if kwargs:\n        pm_message = \'\'\n        if frame.representation_type == SphericalRepresentation:\n            frame_names = list(frame.get_representation_component_names().keys())\n            lon_name = frame_names[0]\n            lat_name = frame_names[1]\n            if f\'pm_{lon_name}\' in kwargs:\n                pm_message = f"\\n\\n By default, most frame classes expect the longitudinal proper motion to include the cos(latitude) term, named `pm_{lon_name}_cos{lat_name}`. Did you mean to pass in this component?"\n        raise ValueError(\'Unrecognized keyword argument(s) {}{}\'.format(\', \'.join(f"\'{key}\'" for key in kwargs), pm_message))\n\n    # Parse coordinate data from args.\n    if args:\n        if len(args) == 1:\n            _skycoord_kwargs, _components = _parse_coordinate_arg(args[0], frame, units, kwargs)\n            if \'info\' in getattr(args[0], \'__dict__\', ()):  # Check if args[0] has \'info\' attribute.\n                info = args[0].info\n        elif len(args) <= 3:\n            _skycoord_kwargs = {}\n            _components = {}\n            frame_attr_names = list(frame.representation_component_names.keys())\n            repr_attr_names = list(frame.representation_component_names.values())\n            for arg, frame_attr_name, repr_attr_name, unit in zip(args, frame_attr_names, repr_attr_names, units):\n                attr_class = frame.representation_type.attr_classes[repr_attr_name]\n                _components[frame_attr_name] = attr_class(arg, unit=unit)\n        else:\n            raise ValueError(f\'Must supply no more than three positional arguments, got {len(args)}\')\n\n        # Check for conflicts between positional and keyword arguments.\n        for attr, coord_value in _components.items():\n            if attr in valid_components and not np.allclose(coord_value, valid_components[attr]):\n                raise ValueError(_conflict_err_msg.format(attr, coord_value, valid_components[attr], \'SkyCoord\'))\n            valid_components[attr] = coord_value\n\n        # Check for conflicts between positional and SkyCoord attributes.\n        for attr, value in _skycoord_kwargs.items():\n            if attr in valid_skycoord_kwargs and not np.allclose(value, valid_skycoord_kwargs[attr]):\n                raise ValueError(_conflict_err_msg.format(attr, value, valid_skycoord_kwargs[attr], \'SkyCoord\'))\n            valid_skycoord_kwargs[attr] = value\n\n    return valid_skycoord_kwargs, valid_components, info\n'), FunctionImplementation(filepath='astropy/coordinates/sky_coordinate_parsers.py', qualname='_parse_coordinate_arg', code='from astropy.coordinates.sky_coordinate import SkyCoord\nfrom astropy.coordinates.representation import (BaseRepresentation, UnitSphericalRepresentation)\nfrom astropy.coordinates.baseframe import BaseCoordinateFrame, frame_transform_graph\nimport numpy as np\nfrom astropy.utils.misc import isiterable\nfrom astropy.coordinates.angles import Longitude, Latitude\nfrom astropy import units as u\nfrom copy import copy as COPY_IF_NEEDED\nfrom collections.abc import Sequence\n\n\ndef _parse_coordinate_arg(coords, frame, init_kwargs, units):\n    """\n    Single unnamed arg supplied.  This must be:\n    - Coordinate frame with data\n    - Representation\n    - SkyCoord\n    - List or tuple of:\n      - String which splits into two values\n      - Iterable with two values\n      - SkyCoord, frame, or representation objects.\n\n    Returns a dict mapping coordinate attribute names to values (or lists of\n    values)\n    """\n    is_scalar = False\n    components = {}\n    skycoord_kwargs = {}\n\n    frame_attr_names = list(frame.representation_component_names.keys())\n    repr_attr_names = list(frame.representation_component_names.values())\n    repr_attr_classes = list(frame.representation_type.attr_classes.values())\n    n_attr_names = len(repr_attr_names)\n\n    # Handle string input.\n    if isinstance(coords, str):\n        is_scalar = True\n        coords = [coords]\n\n    # Handle SkyCoord, BaseCoordinateFrame, and BaseRepresentation inputs.\n    if isinstance(coords, (SkyCoord, BaseCoordinateFrame)):\n        if not coords.has_data:\n            raise ValueError(\'Cannot initialize from a frame without coordinate data\')\n        data = coords.data.represent_as(frame.representation_type)\n\n        # Handle UnitSphericalRepresentation distance.\n        if isinstance(coords.data, UnitSphericalRepresentation):\n            try:\n                index = repr_attr_names.index(\'distance\')\n            except ValueError:\n                pass\n            else:\n                del repr_attr_names[index]\n                del units[index]\n                del frame_attr_names[index]\n                del repr_attr_classes[index]\n\n        values = [getattr(data, name) for name in repr_attr_names]\n\n        # Handle differentials.\n        if coords.data.differentials and \'s\' in coords.data.differentials:\n            orig_vel = coords.data.differentials[\'s\']\n            vel = coords.data.represent_as(frame.representation_type, frame.get_representation_cls(\'s\')).differentials[\'s\']\n            for frname, reprname in frame.get_representation_component_names(\'s\').items():\n                if reprname == \'d_distance\' and (not hasattr(orig_vel, reprname)) and (\'unit\' in orig_vel.get_name()):\n                    continue\n                values.append(getattr(vel, reprname))\n                units.append(None)\n                frame_attr_names.append(frname)\n                repr_attr_names.append(reprname)\n                repr_attr_classes.append(vel.attr_classes[reprname])\n\n        is_skycoord = isinstance(coords, SkyCoord)\n        for attr in frame_transform_graph.frame_attributes:\n            if (value := getattr(coords, attr, None)) is not None and (is_skycoord or attr not in coords.frame_attributes):\n                skycoord_kwargs[attr] = value\n\n    elif isinstance(coords, BaseRepresentation):\n        if coords.differentials and \'s\' in coords.differentials:\n            diffs = frame.get_representation_cls(\'s\')\n            data = coords.represent_as(frame.representation_type, diffs)\n            values = [getattr(data, name) for name in repr_attr_names]\n            for frname, reprname in frame.get_representation_component_names(\'s\').items():\n                values.append(getattr(data.differentials[\'s\'], reprname))\n                units.append(None)\n                frame_attr_names.append(frname)\n                repr_attr_names.append(reprname)\n                repr_attr_classes.append(data.differentials[\'s\'].attr_classes[reprname])\n        else:\n            data = coords.represent_as(frame.representation_type)\n            values = [getattr(data, name) for name in repr_attr_names]\n\n    # Handle numpy array inputs.\n    elif isinstance(coords, np.ndarray) and coords.dtype.kind in \'if\' and coords.ndim == 2 and coords.shape[1] <= 3:\n        values = coords.transpose()\n\n    # Handle Sequence and numpy array of SkyCoord, BaseCoordinateFrame, and BaseRepresentation inputs.\n    elif isinstance(coords, (Sequence, np.ndarray)):\n        coord_types = (SkyCoord, BaseCoordinateFrame, BaseRepresentation)\n        if any(isinstance(coord, coord_types) for coord in coords):\n            scs = [SkyCoord(coord, **init_kwargs) for coord in coords]\n            for sc in scs[1:]:\n                if not sc.is_equivalent_frame(scs[0]):\n                    raise ValueError(f"List of inputs don\'t have equivalent frames: {sc} != {scs[0]}")\n            not_unit_sphere = not isinstance(scs[0].data, UnitSphericalRepresentation)\n            for fattrnm in scs[0].frame.frame_attributes:\n                skycoord_kwargs[fattrnm] = getattr(scs[0].frame, fattrnm)\n            for fattrnm in scs[0]._extra_frameattr_names:\n                skycoord_kwargs[fattrnm] = getattr(scs[0], fattrnm)\n            values = [np.concatenate([np.atleast_1d(getattr(sc, data_attr)) for sc in scs]) for data_attr, repr_attr in zip(frame_attr_names, repr_attr_names) if not_unit_sphere or repr_attr != \'distance\']\n        else:\n            is_radec = \'ra\' in frame.representation_component_names and \'dec\' in frame.representation_component_names\n            vals = [_parse_one_coord_str(c, is_radec=is_radec) if isinstance(c, str) else c for c in coords]\n            try:\n                n_coords = {len(x) for x in vals}\n            except Exception as err:\n                raise ValueError(\'One or more elements of input sequence does not have a length.\') from err\n            if len(n_coords) > 1:\n                raise ValueError(f\'Input coordinate values must have same number of elements, found {sorted(n_coords)}\')\n            n_coords = n_coords.pop()\n            if n_coords > n_attr_names:\n                raise ValueError(f\'Input coordinates have {n_coords} values but representation {frame.representation_type.get_name()} only accepts {n_attr_names}\')\n            values = [list(x) for x in zip(*vals)]\n            if is_scalar:\n                values = [x[0] for x in values]\n\n    else:\n        raise ValueError(\'Cannot parse coordinates from first argument\')\n\n    # Construct components.\n    try:\n        for frame_attr_name, repr_attr_class, value, unit in zip(frame_attr_names, repr_attr_classes, values, units):\n            components[frame_attr_name] = repr_attr_class(value, unit=unit, copy=COPY_IF_NEEDED)\n    except Exception as err:\n        raise ValueError(f\'Cannot parse first argument data "{value}" for attribute {frame_attr_name}\') from err\n\n    return skycoord_kwargs, components\n'), FunctionImplementation(filepath='astropy/coordinates/angles/core.py', qualname='Longitude.__new__', code="from astropy.coordinates.angles import Angle\nimport numpy as np\nfrom astropy import units as u\nfrom astropy.coordinates.angles import Latitude\n\n\n\ndef __new__(cls, angle, unit=None, wrap_angle=None, **kwargs):\n    if isinstance(angle, Latitude):\n        raise TypeError('A Longitude angle cannot be created from a Latitude angle.')\n    self = super().__new__(cls, angle, unit=unit, **kwargs)\n    if wrap_angle is None:\n        wrap_angle = getattr(angle, 'wrap_angle', self._default_wrap_angle)\n    self.wrap_angle = wrap_angle\n    return self\n"), FunctionImplementation(filepath='astropy/coordinates/angles/core.py', qualname='Longitude.wrap_angle', code='from astropy.coordinates.angles import Angle\n\n\ndef wrap_angle(self):\n    return self._wrap_angle\n'), FunctionImplementation(filepath='astropy/coordinates/angles/core.py', qualname='Angle._wrap_at', code='import numpy as np\nfrom astropy import units as u\nfrom astropy.utils.compat import NUMPY_LT_2_0\n\n\ndef _wrap_at(self, wrap_angle):\n    """\n    Implementation that assumes ``angle`` is already validated\n    and that wrapping is inplace.\n    """\n    a360 = u.degree.to(self.unit, 360.0)\n    wrap_angle = wrap_angle.to_value(self.unit)\n    self_angle = self.view(np.ndarray)\n    if NUMPY_LT_2_0:\n        self_angle = self_angle[np.newaxis]\n    else:\n        wrap_angle = float(wrap_angle)\n    wrap_angle_floor = wrap_angle - a360\n    with np.errstate(invalid=\'ignore\'):\n        wraps = (self_angle - wrap_angle_floor) // a360\n    valid = np.isfinite(wraps) & (wraps != 0)\n    if np.any(valid):\n        self_angle -= wraps * a360\n        self_angle[self_angle >= wrap_angle] -= a360\n        self_angle[self_angle < wrap_angle_floor] += a360\n')]